#{extends 'main.html' /} #{set title:'Load data' /}


 
<h3>Load a new csv file</h3>
 
#{form @Application.saveCSV()}
 
    #{ifErrors}
        <p class="error">
            Please correct these errors.
        </p>
    #{/ifErrors}
     
    <p>
        <label>Path to file:</label>
        <input type="text" name="filepath" id="filepath"/>
    
    </p>
 
    
    <p>
        <input type="submit" value="Load this file" />
    </p>
    
#{/form}



<style> 

body {
	font:12px Arial;
}

path {
	stroke: steelblue;

	/* the width of the plotted line */
	/* stroke-width: 0.1; */

	fill: lightblue;
}

.area {
	fill : lightblue;
	stroke-width: 0;
}


.axis path, 
.axis line {
	fill: none;
	stroke: grey;
	stroke-width: 2;
	shape-rendering: crispEdges;
}

/* the styling of the grid lines on the graph */
.grid .tick {
    stroke: lightgrey;
    stroke-opacity: 0.7;
    shape-rendering: crispEdges;
}
.grid path {
   	stroke-width: 0;
}

.legend {
	font-size: 16px;         
	font-weight: bold;         
	text-anchor: start;
	stroke-width: 2;
	shape-rendering: crispEdges;
}

.brush .extent {
  stroke: #fff;
  fill-opacity: .125;
  shape-rendering: crispEdges;
}


</style>

<div class="container-fluid">
	<div class="row">
		<div class="col-sm-12">
			<div id="chart" class="chart"></div>
		</div>
	</div>
</div>


<script>

// set the dimensions of the canvas / graph
var margin = {top: 30, right: 20, bottom: 50, left: 50};

//var	width = 1200 - margin.left - margin.right;
var width = parseInt(d3.select('#chart').style('width'), 10);
	width = width - margin.left - margin.right;


var	height = 670 - margin.top - margin.bottom;


// function to parse the date time
var parseDate = d3.time.format("%Y%m%d").parse;

// set the ranges
var xScale = d3.time.scale().range([0, width]);
var y = d3.scale.linear().range([height, 0]);



// define the axes
var xAxis = d3.svg.axis().scale(xScale)
	.orient("bottom").ticks(5);
	
var yAxis = d3.svg.axis().scale(y)
	.orient("left").ticks(5);
	

//var buttons = ["A:C WEEK LOAD", "ACC/DEC", "RPE SCORES", "SLEEP", "MUSCLE SORENESS", "HR"];
// define the lines
var playerloadline = d3.svg.line()
	.interpolate("cardinal")
	//.defined(function(d) {return d.T_PLAYER_LOAD != ""; })
	.x(function(d) { return xScale(d.date); })
	.y(function(d) { return y(d.T_PLAYER_LOAD); });

var acuteloadline = d3.svg.line()
	.interpolate("basis")
	//.defined(function(d) {return d.T_PLAYER_LOAD != ""; })
	.x(function(d) { return xScale(d.date); })
	.y(function(d) { return y(d.ACUTE_LOAD); });
	
var chronicloadarea = d3.svg.area()
	.interpolate("basis")
	.x(function(d) { return xScale(d.date); })
	.y0(height)
	.y1(function(d) { return y(d.CHRONIC_LOAD); });
	
var accdecloadline = d3.svg.line()
	.interpolate("basis")
	.x(function(d) { return xScale(d.date); })
	.y(function(d) { return y(d.T_ACC_DEC_LOAD); });
	
var rpescoreline = d3.svg.line()
	.interpolate("basis")
	.x(function(d) { return xScale(d.date); })
	.y(function(d) { return y(d.pExertion); });

var sleepline = d3.svg.line()
	.interpolate("basis")
	.x(function(d) { return xScale(d.date); })
	.y(function(d) { return y(d.sleep); });
	
 var musclesorenessline = d3.svg.line()
 	.interpolate("basis")
 	.x(function(d) { return xScale(d.date); })
 	.y(function(d) { return y(d.muscleSoreness); });
 
 var heartrateline = d3.svg.line()
	.interpolate("basis")
	.x(function(d) { return xScale(d.date); })
	.y(function(d) { return y(d.T_HEART_RATE_EXERTION); });
 
 
 
// Adds the svg canvas
var svg = d3.select('#chart').classed('chart', true)
	.append("svg")
		.attr("width", width + margin.left + margin.right)
		.attr("height", height + margin.top + margin.bottom)
		.style("background-color", "#F5F1F1")
	.append("g")
		.attr("transform", "translate(" + margin.left + ", " + margin.top + ")");
		
// the innersvg prevents data being plotted outside the graph area - same as clipping rect
var innersvg = svg.append("svg")
	.attr("width", width)
	.attr("height", height);


// function to draw the horizontal gridlines
function make_gridline() {		
    return d3.svg.axis()
        .scale(y)
        .orient("left")
        .ticks(5)
}


//var buttons = ["A:C WEEK LOAD", "ACC/DEC", "RPE SCORES", "SLEEP", "MUSCLE SORENESS", "HR"];
// Get the data
var dataset = d3.csv("@{Application.getCSV('4')}", function(error, data) {
	data.forEach(function(d) {
		d.date = parseDate(d.date);
		d.T_PLAYER_LOAD = +(d.T_PLAYER_LOAD / 100);//**************note scaling of large number
		d.T_ACC_DEC_LOAD = +(d.T_ACC_DEC_LOAD / 100);
		d.pExertion = +d.pExertion;
		d.sleep = +d.sleep;
		d.muscleSoreness = +d.muscleSoreness;
		d.T_HEART_RATE_EXERTION = +(d.T_HEART_RATE_EXERTION / 10);
		d.ACUTE_LOAD = +(d.ACUTE_LOAD/100);
		d.CHRONIC_LOAD = +(d.CHRONIC_LOAD/100);
	});
	

	// set the scales for the range of the data
	// the x domain is the extents of the date
	//xScale.domain(d3.extent(data, function(d) { return d.date; }));
	
	// by default showing last 28 days of data
	var daysShown = 28;
	xScale.domain([data[data.length - daysShown -1].date,
	               data[data.length -1].date
	               ]);
	// the y domain starts at 0 and ends at the max value found for sleep or muscle soreness
	y.domain([0, d3.max(data, function(d) {
		return Math.max(d.T_ACC_DEC_LOAD, d.T_PLAYER_LOAD, d.ACUTE_LOAD, d.CHRONIC_LOAD, d.pExertion, d.sleep, d.muscleSoreness); })]);
	
	// add the x axis
	svg.append("g")
		.attr("class", "x axis")
		.attr("id", "xaxis")
		.attr("transform", "translate(0," + height + ")")
		.call(xAxis);
	
	
	draw_chart();
	
	function draw_chart() {
		
		// add the chronic load path line
		innersvg.append("path")
		.attr("class", "area")
		// assigning a unique id attribute
		.attr("id", "ChronicLoad")
		// setting the stroke width on the fly
		.attr("stroke-width", 1)
		.attr("stroke", "lightblue")
		.style("fill", "lightblue")
		.style("opacity",1)
		.attr("d", chronicloadarea(data));
		
		
		// add the a/c load path line
		innersvg.append("path")
		.attr("class", "line")
		// assigning a unique id attribute
		.attr("id", "PlayerLoad")
		// setting the stroke width on the fly
		.attr("stroke-width", 1)
		.style("stroke", "purple")
		.style("fill", "none")
		.attr("d", playerloadline(data));
		
		// add the a/c load path line
		innersvg.append("path")
		.attr("class", "line")
		// assigning a unique id attribute
		.attr("id", "ACLoad")
		// setting the stroke width on the fly
		.attr("stroke-width", 1)
		.style("stroke", "red")
		.style("fill", "none")
		.attr("d", acuteloadline(data));
		

		
		
		// add the acc/dec load path line
		innersvg.append("path")
		.attr("class", "line")
		// assigning a unique id attribute
		.attr("id", "ACCDECLoad")
		// setting the stroke width on the fly
		.attr("stroke-width", 1)
		.style("stroke", "blue")
		.style("fill", "none")
		.attr("d", accdecloadline(data));
		
		// add the rpe load path line
		innersvg.append("path")
		.attr("class", "line")
		// assigning a unique id attribute
		.attr("id", "RPEScore")
		// setting the stroke width on the fly
		.attr("stroke-width", 1)
		.style("stroke", "black")
		.style("fill", "none")
		.attr("d", rpescoreline(data));
		
		// add the sleep line path
		innersvg.append("path")
			.attr("class", "line")
			// assigning a unique id attribute
			.attr("id", "Sleep")
			// setting the stroke width on the fly
			.attr("stroke-width", 1)
			.style("fill", "none")
			.attr("d", sleepline(data));
	
		// add the musclesoreness line path
		innersvg.append("path")
			.attr("id", "muscleSoreness")
			.style("stroke", "green")
			.style("fill", "none")
			.attr("d", musclesorenessline(data));
		
		// add the heart rate line path
		innersvg.append("path")
			.attr("id", "heartrate")
			.style("stroke", "orange")
			.style("fill", "none")
			.attr("d", heartrateline(data));
	}
	
	function re_draw_chart() {

		svg.selectAll("#PlayerLoad")
		.attr("d", playerloadline(data));
		
		svg.selectAll("#ACLoad")
		.attr("d", acuteloadline(data));
		
		svg.selectAll("#ChronicLoad")
		.attr("d", chronicloadarea(data));
		
		svg.selectAll("#ACCDECLoad")
		.attr("d", accdecloadline(data));
		
		svg.selectAll("#RPEScore")
		.attr("d", rpescoreline(data));
		
		svg.selectAll("#Sleep")
			.attr("d", sleepline(data));
	
		// add the musclesoreness line path
		svg.selectAll("#muscleSoreness")
			.attr("d", musclesorenessline(data));
		
		svg.selectAll("#heartrate")
		.attr("d", heartrateline(data));
		
		// update the x axis
		svg.selectAll("#xaxis")
		.call(xAxis);
		
	}
	
	var minN = d3.min(data, function (d) { return d.date; }).getTime(),
		maxN = d3.max(data, function (d) { return d.date; }).getTime();
	var minDate = new Date(minN - 8.64e7),
		maxDate = new Date(maxN + 8.64e7);
	
	var zoom = d3.behavior.zoom()
    .x(xScale)
    .on('zoom', function() {
    	
        if (xScale.domain()[0] < minDate) {
	    var x = zoom.translate()[0] - xScale(minDate) + xScale.range()[0];
            zoom.translate([x, 0]);
        } else if (xScale.domain()[1] > maxDate) {
	    var x = zoom.translate()[0] - xScale(maxDate) + xScale.range()[1];
            zoom.translate([x, 0]);
        }
        re_draw_chart();
    });
	
	


    
    // add the y axis
	svg.append("g")
		.attr("class", "y axis")
		.call(yAxis);
    
    // text label for the y axis
//     svg.append("text")
// 	    .attr("transform", "rotate(-90)")
// 	    .attr("y", 0 - margin.left)
// 	    .attr("x",0 - (height / 2))
// 	    .attr("dy", "1em")
// 	    .style("text-anchor", "middle")
// 	    .text("Value");
    


    // horizontal gridlines
	svg.append("g")			
	    .attr("class", "grid")
	    .call(make_gridline()
	        .tickSize(-width, 0, 0)
	        .tickFormat("")
	    )
	  
	// add a rectangle over the whole lot for zooming    
	svg.append('rect')
	    .attr('width', width)
	    .attr('height', height)
	    .attr("opacity", 0)
	    .call(zoom);
	

		var numButtons = 8;
		var buttonOffset = width/(numButtons + 1);
		

		
		function drawButton(buttontext, buttonid, bordercolor, lineid, i){
			
			var abutton = svg.append("g")
			.attr("transform", "translate("+ (i * buttonOffset) + "," + (height + margin.top -10) + ")");
			
			abutton.append("text")
			.attr("x", 10)             
		    .attr("y", 15)
		    .attr("fill", bordercolor)
	        .text(buttontext);
	        
			// get the width of the text and use it to tailor the width of the rect around it
 			var textWidth = abutton.select("text").node().getBBox().width;
			
			abutton.append("rect")
		    .attr("rx", 0)
		    .attr("ry", 10)
		    .attr("width", textWidth + 20)
	 	    .attr("height", 20)
		    .attr("class", "legend")
		    .attr("id", buttonid) 
		    .attr("cursor", "pointer")
		    .style("fill", "rgba(255,255,0,0.1)")
		    .style("stroke", bordercolor)
		    
		    .on("click", function(){
		    	
		    	var isActive;
		        // Hide or show the line
		        d3.select("#"+lineid)
		        	.style("opacity", function(d) {
		        	// Toggle the active state
		        	this.active = !this.active;
		        	isActive = this.active;
			        return	this.active ? 0 : 1;
		        })
		        
		        // update the button with yellow fill
		        d3.select("#"+buttonid)
		        .style("stroke", isActive ? "grey" : bordercolor)
		        .style("stroke-width", isActive ? 0 : 2)
		    	});
			
		}
		
		// chronic load button
		drawButton("Chronic LOAD", "Chronic_Button", "lightblue", "ChronicLoad", 1);
		
		drawButton("PLAYER LOAD", "PlayerLoad_Button", "purple", "PlayerLoad", 2);
		
		// a/c load button
		drawButton("ACUTE LOAD", "ACUTELoad_Button", "red", "ACLoad", 3);

		//acc/dec load button 	
		drawButton("ACC/DEC", "ACCDEC_Button", "blue", "ACCDECLoad", 4);
			
		// rpe score button
		drawButton("RPE SCORES", "RPE_Button", "black", "RPEScore", 5);
			
		// sleep button
		drawButton("SLEEP", "Sleep_Button", "steelblue", "Sleep", 6);
		
		// muscle soreness
		drawButton("MUS SOR", "MuscleSoreness_Button", "green", "muscleSoreness", 7);
		
		// heart rate
		drawButton("HR", "HR_Button", "orange", "heartrate", 8);

	
	// handling window resizing
	d3.select(window).on('resize', resize);
	
	function resize() {
		console.log("resizing");
	    // update width
	    width = parseInt(d3.select('#chart').style('width'), 10);
	    width = width - margin.left - margin.right;
	    
	    xScale.range([0, width]);
	    buttonOffset = width/(buttons.length + 1);
	    redrawbuttons();
	    re_draw_chart();
	    
	}
	
});


/*


		
			var acloadbutton = svg.append("g")
			.attr("transform", "translate("+ (1 * buttonOffset) + "," + (height + margin.top -10) + ")");
			
			acloadbutton.append("text")
			.attr("x", 5)             
		    .attr("y", 15)
	        .text(buttons[0]);
			
			acloadbutton.append("rect")
		    .attr("rx", 10)
		    .attr("ry", 10)
		    .attr("width", 110)
	 	    .attr("height", 20)
		    .attr("class", "legend")
		    .attr("id", "ACLoad_Button")
		    .attr("cursor", "pointer")
		    .style("fill", "rgba(255,255,0,0.5)")
		    .style("stroke", "green")
		    
		    .on("click", function(){
		    	var act;
		        // Hide or show the line
		        d3.select("#ACLoad")
		        	.style("opacity", function(d) {
		        	// Toggle the active state
		        	this.active = !this.active;
		        	act = this.active;
			        return	this.active ? 0 : 1;
		        })
		        
		        // update the button with yellow fill
		        d3.select("#ACLoad_Button")
		        .style("fill", act ?  "rgba(255,255,0,0.5)" : "rgba(255,255,255,0)")
		    	});

			
			
// 			svg.append("text")
// 		    .attr("x", 2 * buttonOffset)             
// 		    .attr("y", height + margin.top + 10)    
// 		    .attr("class", "legend")
// 		    .attr("cursor", "pointer")
// 		    .style("fill", "blue")
// 		    .on("click", function(){
// 		        // Determine if current line is visible
// 		        var active   = ACCDECLoad.active ? false : true;
// 		        var newOpacity = active ? 0 : 1;
// 		        // Hide or show the elements
// 		        d3.select("#ACCDECLoad").style("opacity", newOpacity);
// 		        // Update whether or not the elements are active
// 		        ACCDECLoad.active = active;
// 		    	})
// 		        .text(buttons[1]);
			


// 			svg.append("text")
// 		    .attr("x", 3 * buttonOffset)             
// 		    .attr("y", height + margin.top + 10)    
// 		    .attr("class", "legend")
// 		    .attr("cursor", "pointer")
// 		    .style("fill", "black")
// 		    .on("click", function(){
// 		        // Determine if current line is visible
// 		        var active   = RPEScore.active ? false : true;
// 		        var newOpacity = active ? 0 : 1;
// 		        // Hide or show the elements
// 		        d3.select("#RPEScore").style("opacity", newOpacity);
// 		        // Update whether or not the elements are active
// 		        RPEScore.active = active;
// 		    	})
// 		        .text(buttons[2]);

// 		svg.append("text")
// 		    .attr("x", 4 * buttonOffset)             
// 		    .attr("y", height + margin.top + 10)    
// 		    .attr("class", "legend")
// 		    .attr("cursor", "pointer")
// 		    .style("fill", "steelblue")
// 		    .on("click", function(){
// 		        // Determine if current line is visible
// 		        var active   = Sleep.active ? false : true;
// 		        console.log(active);
// 		        var newOpacity = active ? 0 : 1;
// 		        // Hide or show the elements
// 		        d3.select("#Sleep").style("opacity", newOpacity);
// 		        // Update whether or not the elements are active
// 		        Sleep.active = active;
// 		    	})
// 		        .text(buttons[3]);


// 		svg.append("text")
// 		    .attr("x", 5 * buttonOffset)             
// 		    .attr("y", height + margin.top + 10)    
// 		    .attr("class", "legend")
// 		    .attr("cursor", "pointer")
// 		    .style("fill", "red")
// 		    .style("text-anchor", "middle")
// 		    .on("click", function(){
// 		        // Determine if current line is visible
// 		        var active   = muscleSoreness.active ? false : true,
// 		          newOpacity = active ? 0 : 1;
// 		        // Hide or show the elements
// 		        d3.select("#muscleSoreness").style("opacity", newOpacity);
// 		        //d3.select("#blueAxis").style("opacity", newOpacity);
// 		        // Update whether or not the elements are active
// 		        muscleSoreness.active = active;})
// 		        .text(buttons[4]);
	
	// 		svg.append("text")
// 		    .attr("x", 6 * buttonOffset)             
// 		    .attr("y", height + margin.top + 10)    
// 		    .attr("class", "legend")
// 		    .attr("cursor", "pointer")
// 		    .style("fill", "lightblue")
// 		    .style("text-anchor", "middle")
// 		    .on("click", function(){
// 		        // Determine if current line is visible
// 		        var active   = heartrate.active ? false : true,
// 		          newOpacity = active ? 0 : 1;
// 		        // Hide or show the elements
// 		        d3.select("#heartrate").style("opacity", newOpacity);
// 		        //d3.select("#blueAxis").style("opacity", newOpacity);
// 		        // Update whether or not the elements are active
// 		        heartrate.active = active;})
// 		        .text(buttons[5]);
	
	var brush = d3.svg.brush()
	    .x(xScale)
	    .on("brush", brushmove)
	    .on("brushend", brushend);

	svg.append("g")
	    .attr("class", "brush")
	    .call(brush)
	  	.selectAll('rect')
	    .attr('height', height);


function brushmove() {
	  var extent = brush.extent();
	    is_brushed = extent[0] <= extent[1];
	    return is_brushed;
	}

function brushend() {
	  get_button = d3.select(".clear-button");
	  if(get_button.empty() === true) {
	    clear_button = svg.append('text')
	      .attr("y", 460)
	      .attr("x", 825)
	      .attr("class", "clear-button")
	      .text("Clear Brush");
	  }
	  xScale.domain(brush.extent());

	  re_draw_chart();

	  d3.select(".brush").call(brush.clear());

	  clear_button.on('click', function(){
		  xScale.domain(d3.extent(data, function(d) { return d.date; }));
		  re_draw_chart();
	    clear_button.remove();
	  });
}
*/
  
</script>


